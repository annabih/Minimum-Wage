*******************************************************************************************************************************************************************************************
*** Titel: Distributive Effects of a Comprehensive Minimum Wage in Austria: Overall Poverty Analysis
*** Master Thesis Socioeconomics, Uni Wien
*** Version: V1
*** Date: 12.12.2024
*** Aim: Overall poverty rate calculation (60% median threshold, after means tested benefits on household level)
*** Note: Poverty threshold is recalculated for each year and each scenario
*******************************************************************************************************************************************************************************************


clear all
set more off

use "C:\Users\ALochbih\OneDrive - Bundesarbeitskammer\Desktop\EUROMOD\InWorkPoverty\Stata\Policy_V1_MA_AllYears.dta"
global output "C:/Users/anna/Desktop/Ergebnisse"

local years "2015 2016 2017 2018 2019 2020 2021 2022"
local scenarios "factual v1 v2 v3 v4 v5 v6 v7 v8 v9 v10"

di _n "=== Original observations: " _N " ===" _n

***********************************************
* STRING TO NUMERIC CONVERSION (comma to dot)
***********************************************

local numeric_vars "ils_dispy dwt dag"

foreach var of local numeric_vars {
    capture confirm variable `var'
    if _rc == 0 {
        capture confirm string variable `var'
        if _rc == 0 {
            di "Converting `var' from string to numeric..."
            replace `var' = subinstr(`var', ",", ".", .)
            destring `var', replace force
            di "  -> `var' converted"
        }
    }
    else {
        di as error "WARNING: Variable `var' not found!"
    }
}

**********************************
* Check if ils_dispy exists
**********************************

capture confirm variable ils_dispy
if _rc != 0 {
    di as error "ERROR: Variable ils_dispy not found in dataset!"
    di as error "Available income variables:"
    describe *disp* *inc*
    error 111
}

**********************************
* Renaming variables for clarity
**********************************

rename dag age
label variable age "Age"

gen ind_disp_inc = ils_dispy
label variable ind_disp_inc "Individual disposable income (from ils_dispy)"

capture drop euq_inc_hh

di _n "Variables prepared successfully" _n

*************************************************************
* CALCULATE EQUIVALIZED HOUSEHOLD INCOME (Modified OECD Scale)
*************************************************************

di _n "=== Calculating equivalized household income ===" _n
di _n "=== Using R-style reference person (first person with age >= 14) ===" _n

capture drop eq_weight
capture drop ref_person
capture drop row_num

* Generate row number within each household (preserving original order)
bysort year scenario idhh: gen row_num = _n

* Step 1: Find first adult (age >= 14) in each household
bysort year scenario idhh: gen is_adult = (age >= 14)
bysort year scenario idhh: gen adult_cumsum = sum(is_adult)
gen ref_person = (is_adult == 1 & adult_cumsum == 1)

* Step 2: Assign equivalence weights (Modified OECD Scale)
gen eq_weight = .

* First: Check if first adult in household -> weight 1
replace eq_weight = 1.0 if ref_person == 1

* Second: Other adults get weight 0.5
replace eq_weight = 0.5 if age >= 14 & ref_person == 0

* Third: Children get weight 0.3
replace eq_weight = 0.3 if age < 14

label variable ref_person "Reference person (row 1 AND age >= 14,)"
label variable eq_weight "Equivalence weight (Modified OECD)"

* Creat household equivalent weigths
bysort year scenario idhh: egen hh_eq_weight = total(eq_weight)
label variable hh_eq_weight "Household equivalence factor (OECD)"

* Creat household disposabel income
bysort year scenario idhh: egen hh_ils_dispy = total(ils_dispy)
label variable hh_ils_dispy "Total household disposable income"

* Create equalized disposable household income
gen eq_hh_ils_dispy = hh_ils_dispy / hh_eq_weight
label variable eq_hh_ils_dispy "Equivalized household disposable income"

****************************************
* Calculate poverty threshold per year and scenario
****************************************
tempfile thresholds
tempname h

postfile `h' int year str10 scenario double median_eq_hh_ils_dispy pov_threshold_60 using `thresholds', replace

foreach yr of local years {
    foreach scen of local scenarios {

        quietly count if year==`yr' & scenario=="`scen'"
        if r(N)==0 continue

        quietly _pctile eq_hh_ils_dispy [pw=dwt] if year==`yr' & scenario=="`scen'", p(50)
        local median_val = r(r1)

        post `h' (`yr') ("`scen'") (`median_val') (0.60*`median_val')
        di "Year `yr' `scen' Median=" %12.2f `median_val' " Threshold=" %12.2f (0.60*`median_val')
    }
}

postclose `h'

****************************************
* Merge thresholds back to micro data
****************************************
merge m:1 year scenario using `thresholds', nogen

* ****************************************
* Generate poverty status (individual level)
* ****************************************

* Generate at risk of poverty variable
gen byte arop = .
replace arop = 1 if eq_hh_ils_dispy < pov_threshold_60 & !missing(pov_threshold_60)
replace arop = 0 if eq_hh_ils_dispy >= pov_threshold_60 & !missing(pov_threshold_60)
label variable arop "At-risk-of-poverty (60% median eq HH disposable income)"

* Generate arop gap absolut
gen double arop_gap_abs = .
replace arop_gap_abs = pov_threshold_60 - eq_hh_ils_dispy if arop == 1
label variable arop_gap_abs "Poverty gap absolute (eq HH disposable income)"

* Generate arop gap %
gen double arop_gap_rel = .
replace arop_gap_rel = ((pov_threshold_60 - eq_hh_ils_dispy) / pov_threshold_60) * 100 if arop == 1
label variable arop_gap_rel "Relative poverty gap (% of 60% median eq HH income)"
